package ANU.RSISE.android.dexParser.encoding;

import ANU.RSISE.android.dexParser.container.FieldContainer;
import ANU.RSISE.android.dexParser.container.MethodContainer;
import ANU.RSISE.android.dexParser.container.StringContainer;
import ANU.RSISE.android.dexParser.container.TypeContainer;
import ANU.RSISE.android.dexParser.container.DexContainer;

public class CodeInterpreter {

	public static class OpCode
	{
		public static final int LITERAL_PARAM = 0x10;
		public static final int STRING_PARAM = 0x08;
		public static final int TYPE_PARAM = 0x04;
		public static final int FIELD_PARAM = 0x02;
		public static final int METHOD_PARAM = 0x01;
		public static final int NO_PARAM = 0x00;
		
		public int address;
		public String str_code;
		public int register_size;
		public boolean literal_exists;
		public boolean string_exists;
		public boolean type_exists;
		public boolean field_exists;
		public boolean method_exists;
		public int[] registers;
		public long literal;
		public StringContainer.StringItem string_item;
		public TypeContainer.TypeItem type_item;
		public FieldContainer.FieldItem field_item;
		public MethodContainer.MethodItem method_item;
		public int read_count;
		
		public OpCode(int address, String str_code, int read_count, int register_size, int param, DexContainer dc, long ... values)
		{
			this.address = address;
			this.str_code = str_code;
			this.register_size = register_size;
			this.literal_exists = (param & 0x10) != 0;
			this.string_exists = (param & 0x08) != 0;
			this.type_exists = (param & 0x04) != 0;
			this.field_exists = (param & 0x02) != 0;
			this.method_exists = (param & 0x01) != 0;
			this.read_count = read_count;
			
			registers = new int[register_size];
			for (int i = 0; i < register_size; i++) this.registers[i] = (int)values[i];
			
			int idx = register_size;
			
			if (literal_exists) {this.literal = values[idx++];}
			if (string_exists) {string_item = dc.sc.items[(int)values[idx++]];}
			if (type_exists) {type_item = dc.tc.items[(int)values[idx++]];}
			if (field_exists) {field_item = dc.fc.items[(int)values[idx++]];}
			if (method_exists) {method_item = dc.mc.items[(int)values[idx++]];}
			
		}
		
		public boolean isStringExists() {return string_exists;}
		public boolean isTypeExists() {return type_exists;}
		public boolean isFieldExists() {return field_exists;}
		public boolean isMethodExists() {return method_exists;}
		
		public String toString()
		{
			StringBuilder sb = new StringBuilder();
			
			sb.append(address + " : " + str_code + " - Registers : {");
			if (register_size > 0)
			{
				sb.append("v" + registers[0]);
				for (int i = 1; i < register_size; i++)
				{
					sb.append(", v" + registers[i]);
				}
			}
			sb.append("}");
			if (literal_exists) sb.append(" -> " + literal + "@value");
			if (string_exists) sb.append(" -> " + string_item.str_data + " (string)");
			if (type_exists) sb.append(" -> " + type_item.str_type + " (type)");
			if (field_exists) sb.append(" -> " + field_item.toString() + " (field)");
			if (method_exists) sb.append(" -> " + method_item.toString() + " (method)");
			
			return sb.toString();
		}
	}
	
	public static OpCode interpretCode(DexContainer dc, short[] bytecode, int index)
	{
		OpCode retVal = null;
		switch ((bytecode[index] & 0x00FF) >> 0)
		{
			case (0x00) : 
			{
				switch ((bytecode[index] & 0xFF00) >> 8)
				{
					case (0x00) : retVal = new OpCode(index, "00 (nop)", 1, 0, OpCode.NO_PARAM, dc); break;
					// packed-switch-payload
					case (0x01) : 
					{
						int size = bytecode[index + 1];
						long data[] = new long[size + 2];
						data[0] = size;
						data[1] = bytecode[index + 1] | (bytecode[index + 2] << 16);
						for(int i = 1; i <= size; i++)
						{
							data[i + 1] = bytecode[index + (2*i) + 1] | (bytecode[index + (2*i) + 2] << 16);
						}
						retVal = new OpCode(index, "00 (packed-switch)", (size * 2) + 4, size + 2, OpCode.NO_PARAM, dc, data);
						break;
					}
					// sparse-switch-payload
					case (0x02) :
					{
						int size = bytecode[index + 1];
						long data[] = new long[2 * size + 1];
						data[0] = size;
						for(int i = 0; i < size; i++)
						{
							data[i + 1] = bytecode[index + (2*i) + 1] | (bytecode[index + (2*i) + 2] << 16);
						}
						for(int i = 0; i < size; i++)
						{
							data[size + i + 1] = bytecode[index + (2*(size + i)) + 1] | (bytecode[index + (2*(size + i)) + 2] << 16);
						}
						retVal = new OpCode(index, "00 (sparse-switch)", (size * 2) + 4, 2 * size + 1, OpCode.NO_PARAM, dc, data);
						break;
					}
					// fill-array-data-payload
					case (0x03) :
					{
						int width = bytecode[index + 1];
						int size = bytecode[index + 2] | (bytecode[index + 3] << 16);
						long data[] = new long[width * size];
						data[0] = width;
						data[1] = size;
						for(int i = 0; i < size * width; i++)
						{
							data[i + 2] = bytecode[index + i + 4];
						}
						retVal = new OpCode(index, "00 (fill-array-data)", (size * 2) + 4, size + 1, OpCode.LITERAL_PARAM, dc, data);
						break;
					}
				}
				break;
			}
			case (0x01) : retVal = new OpCode(index, "01 (move)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12); break;
			case (0x02) : retVal = new OpCode(index, "02 (move/from16)", 2, 2, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x03) : retVal = new OpCode(index, "04 (move/16)", 3, 2, OpCode.NO_PARAM, dc, bytecode[index + 1], bytecode[index + 2]); break;
			case (0x04) : retVal = new OpCode(index, "04 (move-wide)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12); break;
			case (0x05) : retVal = new OpCode(index, "05 (move-wide/from16)", 2, 2, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x06) : retVal = new OpCode(index, "06 (move-wide/16)", 3, 2, OpCode.NO_PARAM, dc, bytecode[index + 1], bytecode[index + 2]); break;
			case (0x07) : retVal = new OpCode(index, "07 (move-object)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12); break;
			case (0x08) : retVal = new OpCode(index, "08 (move-object/from16)", 2, 2,OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x09) : retVal = new OpCode(index, "09 (move-object/16)", 3, 2, OpCode.NO_PARAM, dc, bytecode[index + 1], bytecode[index + 2]); break;
			case (0x0A) : retVal = new OpCode(index, "0A (move-result)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x0B) : retVal = new OpCode(index, "0B (move-result-wide)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x0C) : retVal = new OpCode(index, "0C (move-result-object)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x0D) : retVal = new OpCode(index, "0D (move-exception)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x0E) : retVal = new OpCode(index, "0E (return-void)", 1, 0, OpCode.NO_PARAM, dc); break;
			case (0x0F) : retVal = new OpCode(index, "0F (return)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			
			case (0x10) : retVal = new OpCode(index, "10 (return-wide)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x11) : retVal = new OpCode(index, "11 (return-object)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x12) : retVal = new OpCode(index, "12 (const/4)", 1, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12); break;
			case (0x13) : retVal = new OpCode(index, "13 (const/16)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x14) : retVal = new OpCode(index, "14 (const)", 3, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, ((bytecode[index + 2] << 16) | bytecode[index + 1])); break;
			case (0x15) : retVal = new OpCode(index, "15 (const/high16)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, ((bytecode[index + 1]) << 16)); break;
			case (0x16) : retVal = new OpCode(index, "16 (const-wide/16)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x17) : retVal = new OpCode(index, "17 (const-wide/32)", 3, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, ((bytecode[index + 2] << 8) | bytecode[index + 1])); break;
			case (0x18) : retVal = new OpCode(index, "18 (const-wide)", 5, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, ((bytecode[4] << 48) | (bytecode[3] << 32) | (bytecode[index + 2] << 16) | (bytecode[index + 1] << 0)));  break;
			case (0x19) : retVal = new OpCode(index, "19 (const-wide/high16)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1] << 48); break;
			case (0x1a) : retVal = new OpCode(index, "1A (const-string)", 2, 1, OpCode.STRING_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x1b) : retVal = new OpCode(index, "1B (const-string/jumbo)", 3, 1, OpCode.STRING_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 2] << 16) | bytecode[index + 1]); break;
			case (0x1c) : retVal = new OpCode(index, "1C (const-class)", 2, 1, OpCode.TYPE_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x1d) : retVal = new OpCode(index, "1D (monitor-enter)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x1e) : retVal = new OpCode(index, "1E (monitor-exit)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x1f) : retVal = new OpCode(index, "1F (check-cast)", 2, 1, OpCode.TYPE_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x20) : retVal = new OpCode(index, "20 (instance-of)", 2, 2, OpCode.TYPE_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x21) : retVal = new OpCode(index, "21 (array-length)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12); break;
			case (0x22) : retVal = new OpCode(index, "22 (new-instance)", 2, 1, OpCode.TYPE_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x23) : retVal = new OpCode(index, "23 (new-array)", 2, 2, OpCode.TYPE_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x24) : retVal = get35c(index, "24 (filled-new-array)", bytecode, OpCode.TYPE_PARAM, dc);
			case (0x25) : 
			{
				// rough version : just take note of the starting register and the range (only for cosmetics for now)
				int register_start = bytecode[index + 2];
				int register_size = (bytecode[index] & 0xFF00) >> 8;
				retVal = new OpCode(index, "25 (filled-new-array/range)", 3, 1, OpCode.LITERAL_PARAM | OpCode.TYPE_PARAM, dc, register_start, register_size, bytecode[index + 1]); break;
			}
			case (0x26) : retVal = new OpCode(index, "26 (fill-array-data)", 3, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 2] << 16) | bytecode[index + 1]); break;
			case (0x27) : retVal = new OpCode(index, "27 (throw)", 1, 1, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8); break;
			case (0x28) : retVal = new OpCode(index, "28 (goto)", 1, 0, OpCode.LITERAL_PARAM, dc, index + (byte)((bytecode[index] & 0xFF00) >> 8)); break;
			case (0x29) : retVal = new OpCode(index, "29 (goto/16)", 2, 0, OpCode.LITERAL_PARAM, dc, index + (short)bytecode[index + 1]); break;
			case (0x2a) : retVal = new OpCode(index, "2A (goto/32)", 3, 0, OpCode.LITERAL_PARAM, dc, index + (int)((bytecode[index + 2] << 16) | bytecode[index + 1])); break;
			
			case (0x2b) : retVal = new OpCode(index, "2B (packed-switch)", 3, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + (bytecode[index + 2] << 16) | bytecode[index + 1]); break;
			case (0x2c) : retVal = new OpCode(index, "2C (sparse-switch)", 3, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + (bytecode[index + 2] << 16) | bytecode[index + 1]); break;
			
			case (0x2d) : retVal = new OpCode(index, "2D (cmpl-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x2e) : retVal = new OpCode(index, "2E (cmpg-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x2f) : retVal = new OpCode(index, "2F (cmpl-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x30) : retVal = new OpCode(index, "30 (cmpg-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x31) : retVal = new OpCode(index, "31 (cmp-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			
			case (0x32) : retVal = new OpCode(index, "32 (if-eq)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, index + bytecode[index + 1]); break;
			case (0x33) : retVal = new OpCode(index, "33 (if-ne)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, index + bytecode[index + 1]); break;
			case (0x34) : retVal = new OpCode(index, "34 (if-lt)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, index + bytecode[index + 1]); break;
			case (0x35) : retVal = new OpCode(index, "35 (if-ge)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, index + bytecode[index + 1]); break;
			case (0x36) : retVal = new OpCode(index, "36 (if-gt)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, index + bytecode[index + 1]); break;
			case (0x37) : retVal = new OpCode(index, "37 (if-le)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, index + bytecode[index + 1]); break;
			
			case (0x38) : retVal = new OpCode(index, "38 (if-eqz)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + bytecode[index + 1]); break;
			case (0x39) : retVal = new OpCode(index, "39 (if-nez)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + bytecode[index + 1]); break;
			case (0x3a) : retVal = new OpCode(index, "3a (if-ltz)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + bytecode[index + 1]); break;
			case (0x3b) : retVal = new OpCode(index, "3b (if-gez)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + bytecode[index + 1]); break;
			case (0x3c) : retVal = new OpCode(index, "3c (if-gtz)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + bytecode[index + 1]); break;
			case (0x3d) : retVal = new OpCode(index, "3d (if-lez)", 2, 1, OpCode.LITERAL_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, index + bytecode[index + 1]); break;
			// 3e - 43 is unused
			case (0x44) : retVal = new OpCode(index, "44 (aget)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x45) : retVal = new OpCode(index, "45 (aget-wide)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x46) : retVal = new OpCode(index, "46 (aget-object)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x47) : retVal = new OpCode(index, "47 (aget-boolean)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x48) : retVal = new OpCode(index, "48 (aget-byte)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x49) : retVal = new OpCode(index, "49 (aget-char)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x4a) : retVal = new OpCode(index, "4A (aget-short)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x4b) : retVal = new OpCode(index, "4B (aput)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x4c) : retVal = new OpCode(index, "4C (aput-wide)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x4d) : retVal = new OpCode(index, "4D (aput-object)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x4e) : retVal = new OpCode(index, "4E (aput-boolean)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x4f) : retVal = new OpCode(index, "4F (aput-byte)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x50) : retVal = new OpCode(index, "50 (aput-char)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			case (0x51) : retVal = new OpCode(index, "51 (aput-short)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, (bytecode[index + 1] & 0x00FF) >> 0, (bytecode[index + 1] & 0xFF00) >> 8); break;
			
			case (0x52) : retVal = new OpCode(index, "52 (iget)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x53) : retVal = new OpCode(index, "53 (iget-wide)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x54) : retVal = new OpCode(index, "54 (iget-object)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x55) : retVal = new OpCode(index, "55 (iget-boolean)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x56) : retVal = new OpCode(index, "56 (iget-byte)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x57) : retVal = new OpCode(index, "57 (iget-char)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x58) : retVal = new OpCode(index, "58 (iget-short)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x59) : retVal = new OpCode(index, "59 (iput)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x5a) : retVal = new OpCode(index, "5A (iput-wide)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x5b) : retVal = new OpCode(index, "5B (iput-object)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x5c) : retVal = new OpCode(index, "5C (iput-boolean)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x5d) : retVal = new OpCode(index, "5D (iput-byte)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x5e) : retVal = new OpCode(index, "5E (iput-char)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (0x5f) : retVal = new OpCode(index, "5F (iput-short)", 2, 2, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0x0F00) >> 8, (bytecode[index] & 0xF000) >> 12, bytecode[index + 1]); break;
			
			case (0x60) : retVal = new OpCode(index, "60 (sget)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x61) : retVal = new OpCode(index, "61 (sget-wide)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x62) : retVal = new OpCode(index, "62 (sget-object)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x63) : retVal = new OpCode(index, "63 (sget-boolean)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x64) : retVal = new OpCode(index, "64 (sget-byte)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x65) : retVal = new OpCode(index, "65 (sget-char)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x66) : retVal = new OpCode(index, "66 (sget-short)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x67) : retVal = new OpCode(index, "67 (sput)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x68) : retVal = new OpCode(index, "68 (sput-wide)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x69) : retVal = new OpCode(index, "69 (sput-object)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x6a) : retVal = new OpCode(index, "6A (sput-boolean)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x6b) : retVal = new OpCode(index, "6B (sput-byte)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x6c) : retVal = new OpCode(index, "6C (sput-char)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;
			case (0x6d) : retVal = new OpCode(index, "6D (sput-short)", 2, 1, OpCode.FIELD_PARAM, dc, (bytecode[index] & 0xFF00) >> 8, bytecode[index + 1]); break;

			case (0x6e) : retVal = get35c(index, "6E (invoke-virtual)", bytecode, OpCode.METHOD_PARAM, dc); break;
			case (0x6f) : retVal = get35c(index, "6F (invoke-super)", bytecode, OpCode.METHOD_PARAM, dc); break;
			case (0x70) : retVal = get35c(index, "70 (invoke-direct)", bytecode, OpCode.METHOD_PARAM, dc); break;
			case (0x71) : retVal = get35c(index, "71 (invoke-static)", bytecode, OpCode.METHOD_PARAM, dc); break;
			case (0x72) : retVal = get35c(index, "72 (invoke-interface)", bytecode, OpCode.METHOD_PARAM, dc); break;
			// 0x73 is unused
			case (0x74) : 
			{
				// rough version : just take note of the starting register and the range (only for cosmetics for now)
				int register_start = bytecode[index + 2];
				int register_size = (bytecode[index] & 0xFF00) >> 8;
				retVal = new OpCode(index, "74 (invoke-virtual/range)", 3, 1, OpCode.METHOD_PARAM | OpCode.METHOD_PARAM, dc, register_start, register_size, bytecode[index + 1]); break;
			}
			case (0x75) : 
			{
				// rough version : just take note of the starting register and the range (only for cosmetics for now)
				int register_start = bytecode[index + 2];
				int register_size = (bytecode[index] & 0xFF00) >> 8;
				retVal = new OpCode(index, "75 (invoke-super/range)", 3, 1, OpCode.METHOD_PARAM | OpCode.METHOD_PARAM, dc, register_start, register_size, bytecode[index + 1]); break;
			}
			case (0x76) : 
			{
				// rough version : just take note of the starting register and the range (only for cosmetics for now)
				int register_start = bytecode[index + 2];
				int register_size = (bytecode[index] & 0xFF00) >> 8;
				retVal = new OpCode(index, "76 (invoke-direct/range)", 3, 1, OpCode.METHOD_PARAM | OpCode.METHOD_PARAM, dc, register_start, register_size, bytecode[index + 1]); break;
			}
			case (0x77) : 
			{
				// rough version : just take note of the starting register and the range (only for cosmetics for now)
				int register_start = bytecode[index + 2];
				int register_size = (bytecode[index] & 0xFF00) >> 8;
				retVal = new OpCode(index, "77 (invoke-static/range)", 3, 1, OpCode.METHOD_PARAM | OpCode.METHOD_PARAM, dc, register_start, register_size, bytecode[index + 1]); break;
			}
			case (0x78) : 
			{
				// rough version : just take note of the starting register and the range (only for cosmetics for now)
				int register_start = bytecode[index + 2];
				int register_size = (bytecode[index] & 0xFF00) >> 8;
				retVal = new OpCode(index, "78 (invoke-interface/range)", 3, 1, OpCode.METHOD_PARAM | OpCode.METHOD_PARAM, dc, register_start, register_size, bytecode[index + 1]); break;
			}
			// 0x79 - 0x7a are unused
			case (0x7b) : retVal = new OpCode(index, "7B (neg-int)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x7c) : retVal = new OpCode(index, "7C (not-int)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x7d) : retVal = new OpCode(index, "7D (neg-long)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x7e) : retVal = new OpCode(index, "7E (not-long)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x7f) : retVal = new OpCode(index, "7F (neg-float)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x80) : retVal = new OpCode(index, "80 (neg-double)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x81) : retVal = new OpCode(index, "81 (int-to-long)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x82) : retVal = new OpCode(index, "82 (int-to-float)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x83) : retVal = new OpCode(index, "83 (int-to-double)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x84) : retVal = new OpCode(index, "84 (long-to-int)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x85) : retVal = new OpCode(index, "85 (long-to-float)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x86) : retVal = new OpCode(index, "86 (long-to-double)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x87) : retVal = new OpCode(index, "87 (float-to-int)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x88) : retVal = new OpCode(index, "88 (float-to-long)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x89) : retVal = new OpCode(index, "89 (float-to-double)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x8a) : retVal = new OpCode(index, "8A (double-to-int)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x8b) : retVal = new OpCode(index, "8B (double-to-long)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x8c) : retVal = new OpCode(index, "8C (double-to-float)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x8d) : retVal = new OpCode(index, "8D (int-to-byte)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x8e) : retVal = new OpCode(index, "8E (int-to-char)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0x8f) : retVal = new OpCode(index, "8F (int-to-short)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			
			case (0x90) : retVal = new OpCode(index, "90 (add-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x91) : retVal = new OpCode(index, "91 (sub-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x92) : retVal = new OpCode(index, "92 (mul-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x93) : retVal = new OpCode(index, "93 (div-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x94) : retVal = new OpCode(index, "94 (rem-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x95) : retVal = new OpCode(index, "95 (and-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x96) : retVal = new OpCode(index, "96 (or-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x97) : retVal = new OpCode(index, "97 (xor-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x98) : retVal = new OpCode(index, "98 (shl-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x99) : retVal = new OpCode(index, "99 (shr-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x9a) : retVal = new OpCode(index, "9A (ushr-int)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x9b) : retVal = new OpCode(index, "9B (add-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x9c) : retVal = new OpCode(index, "9C (sub-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x9d) : retVal = new OpCode(index, "9D (mul-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x9e) : retVal = new OpCode(index, "9E (div-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0x9f) : retVal = new OpCode(index, "9F (rem-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa0) : retVal = new OpCode(index, "A0 (and-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa1) : retVal = new OpCode(index, "A1 (or-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa2) : retVal = new OpCode(index, "A2 (xor-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa3) : retVal = new OpCode(index, "A3 (shl-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa4) : retVal = new OpCode(index, "A4 (shr-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa5) : retVal = new OpCode(index, "A5 (ushr-long)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa6) : retVal = new OpCode(index, "A6 (add-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa7) : retVal = new OpCode(index, "A7 (sub-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa8) : retVal = new OpCode(index, "A8 (mul-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xa9) : retVal = new OpCode(index, "A9 (div-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xaa) : retVal = new OpCode(index, "AA (rem-float)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xab) : retVal = new OpCode(index, "AB (add-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xac) : retVal = new OpCode(index, "AC (sub-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xad) : retVal = new OpCode(index, "AD (mul-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xae) : retVal = new OpCode(index, "AE (div-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xaf) : retVal = new OpCode(index, "AF (rem-double)", 2, 3, OpCode.NO_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			
			case (0xb0) : retVal = new OpCode(index, "B0 (add-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb1) : retVal = new OpCode(index, "B1 (sub-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb2) : retVal = new OpCode(index, "B2 (mul-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb3) : retVal = new OpCode(index, "B3 (div-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb4) : retVal = new OpCode(index, "B4 (rem-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb5) : retVal = new OpCode(index, "B5 (and-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb6) : retVal = new OpCode(index, "B6 (or-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb7) : retVal = new OpCode(index, "B7 (xor-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb8) : retVal = new OpCode(index, "B8 (shl-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xb9) : retVal = new OpCode(index, "B9 (shr-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xba) : retVal = new OpCode(index, "BA (ushr-int/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xbb) : retVal = new OpCode(index, "BB (add-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xbc) : retVal = new OpCode(index, "BC (sub-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xbd) : retVal = new OpCode(index, "BD (mul-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xbe) : retVal = new OpCode(index, "BE (div-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xbf) : retVal = new OpCode(index, "BF (rem-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc0) : retVal = new OpCode(index, "C0 (and-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc1) : retVal = new OpCode(index, "C1 (or-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc2) : retVal = new OpCode(index, "C2 (xor-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc3) : retVal = new OpCode(index, "C3 (shl-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc4) : retVal = new OpCode(index, "C4 (shr-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc5) : retVal = new OpCode(index, "C5 (ushr-long/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc6) : retVal = new OpCode(index, "C6 (add-float/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc7) : retVal = new OpCode(index, "C7 (sub-float/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc8) : retVal = new OpCode(index, "C8 (mul-float/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xc9) : retVal = new OpCode(index, "C9 (div-float/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xca) : retVal = new OpCode(index, "CA (rem-float/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xcb) : retVal = new OpCode(index, "CB (add-double/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xcc) : retVal = new OpCode(index, "CC (sub-double/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xcd) : retVal = new OpCode(index, "CD (mul-double/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xce) : retVal = new OpCode(index, "CE (div-double/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			case (0xcf) : retVal = new OpCode(index, "CF (rem-double/2addr)", 1, 2, OpCode.NO_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12); break;
			
			case (0xd0) : retVal = new OpCode(index, "D0 (add-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd1) : retVal = new OpCode(index, "D1 (rsub-int(reverse subtract)/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd2) : retVal = new OpCode(index, "D2 (mul-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd3) : retVal = new OpCode(index, "D3 (div-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd4) : retVal = new OpCode(index, "D4 (rem-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd5) : retVal = new OpCode(index, "D5 (and-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd6) : retVal = new OpCode(index, "D6 (or-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			case (0xd7) : retVal = new OpCode(index, "D7 (xor-int/lit16)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0x0F00) >> 8, (bytecode[0] & 0xF000) >> 12, bytecode[1]); break;
			
			case (0xd8) : retVal = new OpCode(index, "D8 (add-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xd9) : retVal = new OpCode(index, "D9 (rsub-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xda) : retVal = new OpCode(index, "DA (mul-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xdb) : retVal = new OpCode(index, "DB (div-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xdc) : retVal = new OpCode(index, "DC (rem-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xdd) : retVal = new OpCode(index, "DD (and-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xde) : retVal = new OpCode(index, "DE (or-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xdf) : retVal = new OpCode(index, "DF (xor-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xe0) : retVal = new OpCode(index, "E0 (shl-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xe1) : retVal = new OpCode(index, "E1 (shr-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			case (0xe2) : retVal = new OpCode(index, "E2 (ushr-int/lit8)", 2, 2, OpCode.LITERAL_PARAM, dc, (bytecode[0] & 0xFF00) >> 8, (bytecode[1] & 0x00FF) >> 0, (bytecode[1] & 0xFF00) >> 8); break;
			
			// 0xe3 - 0xff are not used
			
			default : retVal = new OpCode(index, "XX (unused)", 1, 0, OpCode.NO_PARAM, dc); break;
		}
		
		return retVal;
	}
	
	private static OpCode get35c(int index, String str_code, short[] bytecode, int param_flag, DexContainer dc)
	{
		OpCode retVal = null;
		switch((bytecode[index] & 0xF000) >> 12)
		{
			case (5) : retVal = new OpCode(index, str_code, 3, 5, param_flag, dc, (bytecode[index + 2] & 0x000F), (bytecode[index + 2] & 0x00F0) >> 4, 
					(bytecode[index + 2] & 0x0F00) >> 8, (bytecode[index + 2] & 0xF000) >> 12, (bytecode[index] & 0x0F00) >> 8, bytecode[index + 1]); break;
			case (4) : retVal = new OpCode(index, str_code, 3, 4, param_flag, dc, (bytecode[index + 2] & 0x000F), (bytecode[index + 2] & 0x00F0) >> 4, 
					(bytecode[index + 2] & 0x0F00) >> 8, (bytecode[index + 2] & 0xF000) >> 12, bytecode[index + 1]); break;
			case (3) : retVal = new OpCode(index, str_code, 3, 3, param_flag, dc, (bytecode[index + 2] & 0x000F), (bytecode[index + 2] & 0x00F0) >> 4, 
					(bytecode[index + 2] & 0x0F00) >> 8, bytecode[index + 1]); break;
			case (2) : retVal = new OpCode(index, str_code, 3, 2, param_flag, dc, (bytecode[index + 2] & 0x000F), (bytecode[index + 2] & 0x00F0) >> 4, bytecode[index + 1]); break;
			case (1) : retVal = new OpCode(index, str_code, 3, 1, param_flag, dc, (bytecode[index + 2] & 0x000F), bytecode[index + 1]); break;
			case (0) : retVal = new OpCode(index, str_code, 3, 0, param_flag, dc, bytecode[index + 1]); break;
		}
		return retVal;
	}
}
